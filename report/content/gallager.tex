\section{Gallager regular LDPC codes} \label{sec:gallager_codes}

Gallager's codes are a simple class of \acrshort{ldpc} codes that can achieve
capacity in the large block length regime.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GENERATION                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generation}

The codes generated with the Gallager method are constructed as follows.
\begin{enumerate}
    \item Divide the $N$ bit into $\frac{N}{d_c}$ groups of $d_c$ bits. Each of
          these groups defines a parity check equation (and thus the
          $\frac{M}{d_v} \times N$ matrix $\bm{H}_1$).
    \item To create the $\frac{M (d_v -1)}{M}$ parity check equations left,
          permute the columns of $\bm{H}_1$
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMULATIONS                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Montecarlo simulation on the BMC channel}

The objective of this part is to compare two families of Gallager codes of same
length but different rates (see \autoref{tab:gallager_codes}). For each of these
two families, four degree distributions are compared. The results are shown in
\autoref{fig:gallager_bmc}.

TODO : print number of iterations in BP, number of realizations etc...

\begin{table}
    \centering
    \begin{tabular}{c c c c c}
        length $N$           & \# parity bits $M$   & rate                   & $d_v$ & $d_c$ \\
        \hline \hline
        \multirow{4}{*}{768} & \multirow{4}{*}{384} & \multirow{4}{*}{$1/2$} & 1     & 2     \\
                             &                      &                        & 2     & 4     \\
                             &                      &                        & 3     & 6     \\
                             &                      &                        & 4     & 8     \\
        \hline
        \multirow{4}{*}{768} & \multirow{4}{*}{256} & \multirow{4}{*}{$2/3$} & 1     & 3     \\
                             &                      &                        & 2     & 6     \\
                             &                      &                        & 3     & 9     \\
                             &                      &                        & 4     & 12    \\
    \end{tabular}
    \caption{List of studied Gallager codes}
    \label{tab:gallager_codes}
\end{table}


\begin{figure}
    \centering

    \begin{subfigure}{\textwidth}
        \centering
        \input{figures/gallager_rate-0.5.pgf}
        \caption{$R_c = 1/2$}
    \end{subfigure}%

    \begin{subfigure}{\textwidth}
        \centering
        \input{figures/gallager_rate-0.67.pgf}
        \caption{$R_c = 2/3$}
    \end{subfigure}%
    \caption{%
        Montecarlo simulation of a Gallager codes of length $N = 768$. On the
        top graphs, the codes all have a rate of $1/2$. On the bottom graphs,
        all the codes have a rate of $2/3$. When the (bit or block) error
        probability is zero, the corresponding point is set to the bottom of the
        graph (thus the vertical lines).%
    }
    \label{fig:gallager_bmc}
\end{figure}

First, we observe that, for a fixed degree distribution, both code rates almost
have the same performance in terms of \acrshort{ber} and \acrshort{bler}. More
interestingly, increasing the total degree ($N d_c$ or $M d_v$) lowers the SNR
needed for a given performance by a few dB (from $1$ dB up to $4$ dB). In fact,
a higher total degree means a more connected factor graph i.e. more information
at each node to correct errors. However, increasing the total degree too much
can be detrimental to the overall performance of the decoder. A more connected
factor graph might increase the probability of having short cycles and increases
the decoding time. In fact, we can see this effect in the results: increasing
the total degree from $(d_v=3, d_c=6)$ (resp.  $(d_v=3, d_c=9)$) to $(d_v=4,
    d_c=8)$ (resp.  $(d_v=4, d_c=12)$) does not lead to a significant SNR
improvement (especially or the rate $2/3$ code). But, during the execution of
the decoder, the codes take much longer to decode.